/*

 GT.M GDE Qualifier show for EWD Lite 2013/07/25 12:09
  
  Written by Kiyoshi Sawada <casiopea.tpine@gmail.com>
  Copyright c 2013 Japan DynaSystems Inc.
 
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License (AGPL)
  as published by the Free Software Foundation, either version 3 of
  the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public 
  License along with this program. 
 If not, see http://www.gnu.org/licenses/.
 
*/

module.exports = {

  onSocketMessage: function(ewd) {

    var wsMsg = ewd.webSocketMessage;
    var type = wsMsg.type;
    var params = wsMsg.params;
    var sessid = ewd.session.$('ewd_sessid')._value;
 
    // Login Check
    if (type === 'EWD.form.login') {
      //console.log('login: ' + JSON.stringify(params));
      if (params.password === '') return 'You must enter a password';
      if (params.password !== ewd.session.$('ewd_password')._value) return 'Invalid password';
      ewd.session.setAuthenticated();
      return '';
    } 
    if (!ewd.session.isAuthenticated) return;

    // GDE Qualifier Initialize ^%zgdequalifier global
	if (type === 'initQualifierGet') {
		var result = ewd.mumps.function('InitZgdeQualifier^%nodemGTM2');
		// init Qualifier View
		ewd.sendWebSocketMsg({ type: 'initQualifierView' });
		return '';
    }
	
	// Get GDE Region Qualifier Make Date
    if (type === 'AboutGDEqualifier') {
		var date = new ewd.mumps.GlobalNode('%zgdequalifier');
		return date._value ;
    }
    
    // Get GDE Region Qualifier Data
    if (type === 'getRegQualifierData') {
      var regs  = new ewd.mumps.GlobalNode('%zgdequalifier', ['regs'] );
      var regions = [];
      var journal = [];
      var rowNo = -1;
      var rowJn = -1;
      regs._forEach(function(region, qual) {
        var align = qual.$('ALIGNSIZE')._value; 
        var alloc = qual.$('ALLOCATION')._value; 
        var auto  = qual.$('AUTOSWITCHLIMIT')._value; 
        var befor = qual.$('BEFORE_IMAGE')._value; 
	    if (befor === 0) befor = 'N';
	    if (befor === 1) befor = 'Y';
        var buff  = qual.$('BUFFER_SIZE')._value; 
        var coll  = qual.$('COLLATION_DEFAULT')._value; 
	    if (coll === '') coll = '0';
        var dyn   = qual.$('DYNAMIC_SEGMENT')._value; 
        var epoch = qual.$('EPOCH_INTERVAL')._value; 
        var exten = qual.$('EXTENSION')._value; 
        var filen = qual.$('FILE_NAME')._value; 
        var instf = qual.$('INST_FREEZE_ON_ERROR')._value; 
	    if (instf === 0) instf = 'DISABLED';
        var jrnl  = qual.$('JOURNAL')._value;
	    if (jrnl === 0) jrnl = 'N';
	    if (jrnl === 1) jrnl = 'Y';
        var key   = qual.$('KEY_SIZE')._value; 
        var nulls = qual.$('NULL_SUBSCRIPTS')._value; 
	    if (nulls === 0) nulls = 'NEVER';
        var qdb   = qual.$('QDBRUNDOWN')._value; 
	    if (qdb === 0) qdb = 'DISABLED';
        var rec   = qual.$('RECORD_SIZE')._value; 
        var std   = qual.$('STDNULLCOLL')._value; 
	    if (std === 0) std = 'N';
        var sync  = qual.$('SYNC_IO')._value; 
        var Yiel  = qual.$('YIELD_LIMIT')._value; 
	rowNo++;
	regions.push({
	  rowNo : rowNo ,
          REGION : region ,
          DYNAMIC_SEGMENT : dyn ,
          COLLATION_DEFAULT : coll ,
          RECORD_SIZE : rec ,
          KEY_SIZE : key ,
          NULL_SUBSCRIPTS : nulls ,
          STDNULLCOLL : std ,
          INST_FREEZE_ON_ERROR : instf ,
          QDBRUNDOWN : qdb ,
          JOURNAL : jrnl
	});
	if (jrnl === 'Y') {
	  rowJn++;
	  journal.push({
	    rowNo : rowJn ,
            REGION : region ,
	    FILE_NAME : filen ,
            BEFORE_IMAGE : befor ,
            ALLOCATION : alloc ,
            EXTENSION : exten ,
            AUTOSWITCHLIMIT : auto
	  });
	}
      });
      ewd.sendWebSocketMsg({ type: 'getJournalQualifierData', message: journal });
      return regions;
    }

    
    // Get GDE Segment Qualifier Data for JSON format
    if (type === 'getSegQualifierData') {
      var segs  = new ewd.mumps.GlobalNode('%zgdequalifier', ['segs'] );
      var data = [];
      var rowNo = -1;
      segs._forEach(function(segment, qual) {
        var  acc = qual.$('ACCESS_METHOD')._value; 
        var  all = qual.$('ALLOCATION')._value; 
        var  blc = qual.$('BLOCK_SIZE')._value; 
        var  buc = qual.$('BUCKET_SIZE')._value; 
        var  def = qual.$('DEFER')._value; 
        var  enc = qual.$('ENCRYPTION_FLAG')._value; 
	    if (enc === 0) enc = 'OFF';
        var  ext = qual.$('EXTENSION_COUNT')._value; 
        var  fil = qual.$('FILE_NAME')._value; 
        var  typ = qual.$('FILE_TYPE')._value; 
        var  glb = qual.$('GLOBAL_BUFFER_COUNT')._value; 
        var  lck = qual.$('LOCK_SPACE')._value; 
        var  res = qual.$('RESERVED_BYTES')._value; 
        // var  win = qual.$('WINDOW_SIZE')._value;       
	    rowNo++;
	    data.push({
	      rowNo : rowNo ,
          SEGMENT : segment ,
          FILE_NAME : fil ,
          ACCESS_METHOD : acc ,
          FILE_TYPE : typ , 
          BLOCK_SIZE : blc ,
          ALLOCATION : all , 
          EXTENSION_COUNT : ext ,
          GLOBAL_BUFFER_COUNT : glb ,
          LOCK_SPACE :  lck ,
          RESERVED_BYTES : res , 
          ENCRYPTION_FLAG : enc
 	    });
      });
      return data ;
    }
 
    // Get GDE Names Data for JSON format
    if (type === 'getNames') {
      var names  = new ewd.mumps.GlobalNode('%zgdequalifier', ['nams'] );
      var data = [];
      var rowNo = -1;
      names._forEach(function(Global, reg) {
        var region = reg._value;
        rowNo++;
        if ( Global != "#" ) { 
		  data.push ({ 
			rowNo : rowNo ,  Global : Global ,  Region : region
		  }) ;
		}
      });
      return data;
    }

    // Get GDE Map for JSON format
    if (type === 'getMap') {
      var maps  = new ewd.mumps.GlobalNode('%zgdequalifier', ['maps'] );
      var data = [];
      var rowNo = -1;
      maps._forEach(function(lineNo, subs) {
        var from = subs.$('From')._value ;
        var upto = subs.$('UpTo')._value ;
        var regi = subs.$('Region')._value ;
        var seg  = subs.$('Segment')._value ;
        var file = subs.$('File')._value ;
        rowNo++;
		data.push({
		  rowNo : rowNo , From  : from , UpTo  : upto , Region : regi , Segment : seg , File : file
        });
      });
      return data ;
    }
    
  }
};
